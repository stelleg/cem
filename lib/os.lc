## Memory read and write wrappers ##
mvq = \val.\addr.\w.[w addr val \a.\b.\w._@q]
rdq = \addr.\w.[w addr \a.\w._$q]
mvl = \val.\addr.\w.[w addr val \a.\b.\w._@l]
rdl = \addr.\w.[w addr \a.\w._$l]
mvs = \val.\addr.\w.[w addr val \a.\b.\w._@s]
rds = \addr.\w.[w addr \a.\w._$s]
mvb = \val.\addr.\w.[w addr val \a.\b.\w._@b]
rdb = \addr.\w.[w addr \a.\w._$b]
mv = mvq
rd = rdq

## System calls ##
sys_mmap = \addr.\len.\prot.\flags.\fd.\offset.\w.[w offset fd flags prot len addr \a.\b.\c.\d.\e.\f.(\t.\w._!6 9)]
sys_write = \fd.\buf.\count.\w.[w count buf fd \a.\b.\c.(\t.\w._!3 1)]
sys_read = \fd.\buf.\count.\w.[w count buf fd \a.\b.\c.(\t.\w._!3 0)]
sys_open = \fname.\flags.\mode.\w.[w mode flags fname \a.\b.\c.(\t.\w._!3 2)]
sys_close = \fd.\w.[w fd \a.(\t.\w._!1 3)]
sys_exit = \code.\w.[w code \a.(\t.\w._!1 60)]
sys_socket = \dom.\type.\prot.\w.[w prot type dom \a.\b.\c.(\t.\w._!3 41)]
sys_getpid = \w.[w (\t.\w._!0 39)]
sys_fork = \world.[world (\t.\w._!0 57)]
sys_nanosleep = \rqtp.\rmtp.\w.[w rmtp rqtp \a.\b.(\t.\w._!2 35)]
sys_munmap = \addr.\len.\w.[w len addr \a.\b.(\t.\w._!2 11)]
sys_wait = \pid.\w.[w pid (\pid.\a.\b.\t.\w._!3 0 0 61)]
sys_execve = \fname.\argv.\envp.\w.[w envp argv fname \a.\b.\c.(\w.\t._!3 59)]

## Basic IO ##
pageSize = 4096
malloc = \len.(sys_mmap 0 len 255 34 (-' 1) 0)
free = \ptr.(sys_munmap ptr 1)
sleep = \sec.\nsec.(>>= (malloc 2) \p.
  (>> (mvq sec p) 
  (>> (mvq nsec (p + 8)) 
  (>>= (sys_nanosleep p p) \r.
  (free p)))))
newPage = (malloc pageSize)
read-utf8-char-from-buf = \p.(>>= (rdb p) \c1.
  (c1 / 128 = 0 (return (pair c1 1)) (>>= (rdb (p + 1)) \c2.{c2' = (2 ^ 8 * c2 + c1)}
  (c2 / 128 = 0 (return (pair c2' 2)) (>>= (rdb (p + 2)) \c3.{c3' = (2 ^ 16 * c3 + c2')}  
  (c3 / 128 = 0 (return (pair c3' 3)) (>>= (rdb (p + 3)) \c4.
  (return (pair (2 ^ 24 * c4 + c3') 4)))))))))
write-utf8-char-to-buf = \c.\p.[
  (c >= (2 ^ 24) (>> (mvl c p) (return 4)))
  (c >= (2 ^ 16) (>> (mvs c p) (>> (mvb (c / (2 ^ 16)) (p + 2)) (return 3))))
  (c >= (2 ^ 8)  (>> (mvs c p) (return 2)))
  (>> (mvb c p) (return 1))]
readStrBuf = (Y \rstr.\loc.\n.(n = 0
  (return nil)
  (>>= (read-utf8-char-from-buf loc) \p.(p \c.\n'.(c = 0 
    (return ;)
    (>>= (rstr (loc + n') (n - 1)) \s.(return (: c s))))))))
putStrBuf = \size.\buf.(Y \putStrBuf.\loc.\s.{finished = (>> (mvb 0 loc) (return (pair (loc + 1) nil)))}(s
  finished
  \h.\t.(loc - buf >= size
    finished 
    (>>= (write-utf8-char-to-buf h loc) \n.(putStrBuf (loc + n) t)))) buf)
open = \fname.(>>= newPage \nameBuf.(
  >> (putStrBuf pageSize nameBuf fname)
  (sys_open nameBuf 66 0)))
putPtrBuf = (Y \putPtrBuf.\loc.\s.(s 
  (>> (mv nil loc) (return (loc + 8)))
  \h.\t.(>> (mv h loc) (putPtrBuf (loc + 8) t))))
readPtrBuf = (Y \rstr.\loc.\n.(n <= 0
  (return nil)
  (>>= (rd loc) \p.(p = 0
    (return nil)
    (>>= (rstr (loc + 8) (n - 1)) \s.(return (: p s)))))))
writeFd = \fd.\str.(>>= newPage \iobuf.(>> (Y \writeFd.\str.(
  >>= (putStrBuf pageSize iobuf str) \p.(p \p.\s.(
  >>= (sys_write fd iobuf (p - iobuf)) \n.(
  s (return n) \h.\t.(writeFd s))))
) str) (free iobuf)))
writeFile = \fname.\str.(newPage 0 >>= \iobuf.(
  >>= (open fname) \fd.(
  >> (fd > 1024 (sys_exit 2) (writeFd fd str))
  (free iobuf))))
readFd = \fd.(>>= newPage \iobuf.(Y \readFd.(
  >>= (sys_read fd iobuf pageSize) \n.(
  n >= pageSize 
    (>>= (readStrBuf iobuf n) \s.(s
      (return nil)
      \h.\t.(>>= readFd (append (cons h t)))))
    (readStrBuf iobuf n)))))
readFile = \fname.(>>= newPage \iobuf.(
  >>= (open fname) \fd.(
  >> (fd > 1024 
    (sys_exit 2)
    (readFd fd))
  (free iobuf))))
putStr = (writeFd 1)
putStrLn = \s.(writeFd 1 (append s "\n"))
print = putStrLn
getContents = (readFd 0)
getLine = (>>= getContents \s.(return (takeWhile \c.[c '\n' !=] s)))
interact = \f.(>>= getContents \s.[putStr f s])
getArgs = [tail (map (flip readStrBuf 1024)) (readPtrBuf argv argc)]
getEnv = [tail (map (flip readStrBuf 1024)) (readPtrBuf envp 1024)]

# Prelude-like utilities that require IO, e.g. partial functions
error = \s.(>> (putStrLn s) (sys_exit 1))
PME = (error "Pattern match error")
head = \l.(l (error "head of empty list") \h.\t.h)
index = \n.\k.(Y \index.\n.\k.\cont.(n = 0
  cont
  \x.(index (n - 1) k (k = n x cont))) n (n - k + 1) (error "index failed"))
listIndex = (Y \listIndex.\n.\l.(l (error "listIndex failed") \h.\t.(n = 0 h (listIndex (n - 1) t))))
fst = (index 2 1)
snd = (index 2 2)
sprintf_ = \k.(Y \printf.\acc.\l.(l (k acc) \h.\t.(h = '%'
  (t (error "misformed format") \h.\t'.[
    (h = 'd' \i.(printf (append acc (showInt i)) t'))
    (h = 'c' \c.(printf (append acc (cons c nil)) t'))
    (h = 's' \s.(printf (append acc s) t'))
    (h = 'b' \b.(printf (append acc (showBool b)) t'))
    (error "misformed format")])
  (printf (append acc (cons h nil)) t))) nil)
sprintf = (sprintf_ id)
printf = (sprintf_ print)
putWords = (Y \putWords.\ws.\loc.(ws
  (pair loc nil)
  \w.\ws.(putStrBuf 1024 loc w
    \loc'.\str.(putWords ws loc' \loc''.\ws.(pair loc'' (cons loc ws))))))
exec = \fname.\argv.{buf = (newPage nil)}[
  (putStrBuf pageSize buf fname) \l.\str.
  (putWords argv l \al.\alocs.
  (putPtrBuf al (cons buf alocs) \l.
  (putWords argv l \el.\elocs.
  (putPtrBuf el (cons buf elocs) \l.
  (sys_execve buf al el)))))
]

