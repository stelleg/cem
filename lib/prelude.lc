Y = \g.(\x.[g x x] \x.[g x x])
add = \n.\m.[n m +]
sub = \n.\m.[n m -]
mul = \n.\m.[n m *]
div = \n.\m.[n m /]
mod = \n.\m.[n m %]
eq = \n.\m.[n m =]
neq = \n.\m.[n m /=]
False = \t.\f.f
True = \t.\f.t
and = \a.\b.(a b False)
or = \a.\b.(a True b)
not = \a.(a False True)
Nothing = \n.\j.n
Just = \a.\n.\j.(j a)
Left = \v.\l.\r.(l v)
Right = \v.\l.\r.(r v)
Cons = \h.\t.\n.\c.(c h t)
Nil = True
Pair = \f.\s.\p.(p f s)
gcd = (Y \gcd.\a.\b.([b 0 =] a (gcd b [a b %])))
lcm = \a.\b.(div [a b *] (gcd a b))
even = \n.[[n 2 %] 0 =]
odd = \n.[[n 2 %] 1 =]
id = \x.x
const = True
compose = \f.\g.\x.[f g x]
flip = \f.\b.\a.(f a b)
until = (Y \until.\p.\f.\x.(p x x (until p f (f x))))
map = (Y \map.\f.\xs.(xs Nil \h.\t.(Cons (f h) (map f t))))
null = \l.(l True \x.\xs.False)
length = \xs.((Y \length.\xs.\acc.(xs acc \h.\t.[[acc 1 +] length t])) xs 0)
foldl = (Y \foldl.\f.\a.\bs.(bs a \b.\bs.(foldl f (f a b) bs)))
foldr = (Y \foldr.\f.\a.\bs.(bs a \b.\bs.(f b (foldr f a bs))))
append = \as.\bs.(foldr Cons bs as)
reverse = (foldl (flip Cons) Nil) 
any = \p.\xs.(foldl or (map p xs))
all = \p.\xs.(foldl and (map p xs))
concat = (foldr append Nil)
concatMap = \f.(foldr (compose append f) Nil)
filter = \c.(Y \filter.\ls.(ls Nil \h.\t.(c h (Cons h) id (filter t))))
scanl = (Y \scanl.\f.\q.\ls.(Cons q (ls Nil \x.\xs.(scanl f (f q x) xs))))
scanr = (Y \scanr.\f.\q.\ls.(Cons q (ls (Cons q Nil) \x.\xs.(scanr f x q Nil \q.\qs.(Cons (f x q))))))
iterate = (Y \iterate.\f.\x.(Cons x (iterate f (f x))))
repeat = (iterate id)
take = (Y \take.\n.\xs.(xs Nil \x.\xs.([n 0 <=] Nil (Cons x (take [n 1 -] xs)))))
replicate = \n.\x.(take n (repeat x))
cycle = \xs.[concat repeat xs]
drop = (Y \drop.\n.\xs.(xs Nil \x.\xs.([n 1 =] xs (drop [n 1 -] xs))))
tail = (drop 1)
splitAt = \n.\xs.(Pair (take n xs) (drop n xs))
takeWhile = (Y \takeWhile.\f.\xs.(xs Nil \x.\xs.(f x (Cons x (takeWhile f xs)) Nil)))
dropWhile = (Y \dropWhile.\f.\xs.(xs Nil \x.\xs.(f x (dropWhile f xs) (Cons x xs))))
showInt = (compose reverse \i.([i 0 =] (Cons 48 Nil) 
  (Y \showInt.\i.([i 0 =] Nil (Cons [[i 10 %] 48 +] [showInt i 10 /])) i)))
readInt = (compose (Y \readInt.\n.(n 0 \h.\t.(add [h 48 -] [(readInt t) 10 *])))
  (compose reverse (takeWhile \h.(and [h 48 >=] [h 58 <]))))
showBool = \b.(b "True" "False")
forever = (Y \forever.\comp.[comp \s.(forever comp)])
isSpace = \c.(all \c'.(not [c c' =]) " \n\t\r")
partition = \f.(Y \partition.\s.\acc.(s (Pair acc Nil) \h.\t.(f h (Pair acc s)
    (partition t (append acc))))) 
splitWhen = \f.(Y \splitWhen.\s.(dropWhile f s Nil \h.\t.(\w.\c.(Y \splitWhen.\s.(dropWhile f s)))))
words = (splitWhen isSpace)
if = id
from = (iterate \x.[x 1 +])
range = \s.\e.(take [[e s -] 1 +] (from s))
then = \cont.\result.cont
sum = (foldr add 0)
max = \x.\y.([x y >] x y)
min = \x.\y.([x y <] x y)
unlines = (concatMap (flip append "\n"))
applyFromList = (Y \al.\f.\l.(l f \h.\t.(al (f h) t))) 
signum = \n.[([n 0 =] 0) ([n 0 >] 1) [0 1 -]]
abs = \n.([n 0 <] [[0 1 -] n *] n)
