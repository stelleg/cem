Y = \g.(\x.[g x x] \x.[g x x])
add = \n.\m.[n m +]
sub = \n.\m.[n m -]
mul = \n.\m.[n m *]
div = \n.\m.[n m /]
mod = \n.\m.[n m %]
eq = \n.\m.[n m =]
neq = \n.\m.[n m /=]
False = \t.\f.f
True = \t.\f.t
and = \a.\b.(a b False)
or = \a.\b.(a True b)
not = \a.(a False True)
Nothing = \n.\j.n
Just = \a.\n.\j.(j a)
Left = \v.\l.\r.(l v)
Right = \v.\l.\r.(r v)
Cons = \h.\t.\n.\c.(c h t)
Nil = True
nil? = \l.(l True \h.\t.False)
Pair = \f.\s.\p.(p f s)
gcd = (Y \gcd.\a.\b.([b 0 =] a (gcd b [a b %])))
lcm = \a.\b.(div [a b *] (gcd a b))
even = \n.[[n 2 %] 0 =]
odd = \n.[[n 2 %] 1 =]
id = \x.x
const = True
compose = \f.\g.\x.[f g x]
flip = \f.\b.\a.(f a b)
until = (Y \until.\p.\f.\x.(p x x (until p f (f x))))
map = (Y \map.\f.\xs.(xs Nil \h.\t.(Cons (f h) (map f t))))
null = \l.(l True \x.\xs.False)
length = \xs.((Y \length.\xs.\acc.(xs acc \h.\t.[[acc 1 +] length t])) xs 0)
foldl = (Y \foldl.\f.\a.\bs.(bs a \b.\bs.(foldl f (f a b) bs)))
foldr = (Y \foldr.\f.\a.\bs.(bs a \b.\bs.(f b (foldr f a bs))))
append = \as.\bs.(foldr Cons bs as)
reverse = (foldl (flip Cons) Nil) 
any = \p.\xs.(foldr or False (map p xs))
all = \p.\xs.(foldr and True (map p xs))
concat = (foldr append Nil)
concatMap = \f.(foldr (compose append f) Nil)
filter = \c.(Y \filter.\ls.(ls Nil \h.\t.(c h (Cons h) id (filter t))))
scanl = (Y \scanl.\f.\q.\ls.(Cons q (ls Nil \x.\xs.(scanl f (f q x) xs))))
scanr = (Y \scanr.\f.\q.\ls.(Cons q (ls (Cons q Nil) \x.\xs.(scanr f x q Nil \q.\qs.(Cons (f x q))))))
iterate = (Y \iterate.\f.\x.(Cons x (iterate f (f x))))
repeat = (iterate id)
take = (Y \take.\n.\xs.(xs Nil \x.\xs.([n 0 <=] Nil (Cons x (take [n 1 -] xs)))))
replicate = \n.\x.(take n (repeat x))
cycle = \xs.[concat repeat xs]
drop = (Y \drop.\n.\xs.(xs Nil \x.\xs.([n 1 =] xs (drop [n 1 -] xs))))
tail = (drop 1)
splitAt = \n.\xs.(Pair (take n xs) (drop n xs))
takeWhile = (Y \takeWhile.\f.\xs.(xs Nil \x.\xs.(f x (Cons x (takeWhile f xs)) Nil)))
dropWhile = (Y \dropWhile.\f.\xs.(xs Nil \x.\xs.(f x (dropWhile f xs) (Cons x xs))))
split = \f.(Y \split.\xs.(xs (Pair Nil Nil) \h.\t.(f h 
  (Pair Nil t)
  (split t \acc.\rem.(Pair (Cons h acc) rem)))))
showInt = \i.{showPosInt = (Y \showPosInt.\i.([i 0 =]
    Nil 
    (Cons [[i 10 %] 48 +] [showPosInt i 10 /])))} [
  ([i 0 =] "0") 
  ([i 0 <] (Cons '-' (showPosInt [0 i -])))
  (showPosInt i)
]
readInt = (compose (Y \readInt.\n.(n 0 \h.\t.(add [h 48 -] [(readInt t) 10 *])))
  (compose reverse (takeWhile \h.(and [h 48 >=] [h 58 <]))))
showBool = \b.(b "True" "False")
forever = \comp.(Y \forever.\iw.(comp iw \w.(forever w)))
isSpace = \c.(any \c'.[c c' =] " \n\t\r")
partition = \f.(Y \partition.\s.\acc.(s (Pair acc Nil) \h.\t.(f h (Pair acc s)
    (partition t (append acc))))) 
splitWhen = (Y \splitWhen.\f.\xs.(split f xs \l.\r.(r 
  (l Nil \h.\t.(Cons l Nil))
  \h.\t.(Cons l (splitWhen f r)))))
words = (splitWhen isSpace)
intersperse = \v.(Y \intersperse.\l.(l l \h.\t.(t l 
  \h'.\t'.[(Cons h) (Cons v) intersperse t])))
unwords = (compose concat (intersperse " "))
if = id
from = (iterate \x.[x 1 +])
range = \s.\e.(take [[e s -] 1 +] (from s))
then = \cont.\result.cont
sum = (foldr add 0)
max = \x.\y.([x y >] x y)
min = \x.\y.([x y <] x y)
unlines = (concatMap (flip append "\n"))
applyFromList = (Y \al.\f.\l.(l f \h.\t.(al (f h) t))) 
signum = \n.[([n 0 =] 0) ([n 0 >] 1) [0 1 -]]
abs = \n.([n 0 <] [[0 1 -] n *] n)
zipWith = \f.(Y \zipWith.\as.\bs.(as Nil \a.\at.(bs Nil \b.\bt.
  (Cons (f a b) (zipWith at bt)))))
zip = (zipWith Pair)
nil = 0
initWorld = 0
mapm = \f.(foldr \a.\b.(f a \c.b) nil)
strcmp = \s.\s'.(all id (zipWith \x.\y.[x y =] s s'))
lookup = \elem.\eqfun.(Y \lookup.\l.(l 
  Nothing 
  \h.\t.(h \key.\value.(eqfun elem key
    (Just value)
    (lookup t)))))
