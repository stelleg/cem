# getdents system call
sys_getdents = \fd.\dirent.\count.\w.[w fd dirent count \c.\d.\f.(\t.\w._!3 78)]
ls = \dirname.
  (>>= newPage \dirents.
  (>>= (open dirname) \fd.
  (>>= (sys_getdents fd dirents pageSize) \e.
  (e != 0 (error (sprintf "ls failed: %d" e)) (readStrBuf (dirents + 24) pageSize)))))
        
# pipe system call
sys_pipe = \fdes.\w.[w fdes \f.(\t.\w._!1 22)]
pipe = (>>= newPage \fdes.
       (>> (sys_pipe fdes) 
       (>>= rdl fdes \n1.(rdl (fdes + 4)) \n2.(pair n1 n2))))

# Shell takes a line and executes it after splitting it into words
shell = \line.(words line nil \cmd.\args.
  (>>= sys_fork \n.
  (n = 0 
    (>> (exec cmd args getEnv)))))

# Looks for the command in the PATH environment
envMap = (map (split \c.[c '=' =]) getEnv)
paths = (lookup "PATH" strcmp envMap "path not found!" (splitWhen \c.[c ':' =]))

# Extracts all possible commands using ls output
commands = (mapm \c.[shell (append "/usr/bin/ls ") c] paths)

# Quits on ctrl-d (eof), otherwise returns the line
getLineOrQuit = \world.(takeWhile \c.[c '\n' /=] (readFd 0 world
  (error "goodbye")
  cons))

# Loops forever on getLines and shells
main = (forever \world.[
  (putStr "> ") then 
  shell getLineOrQuit world
] initWorld)

main = {fdes = (newPage nil)}[
  (sys_pipe fdes) \k.\n.
  [(printf "n = %d" n) k] then \k.
  [(printf "in = %d" (rdl fdes)) k] then \k.
  [(printf "out = %d" [rdl fdes 4 +]) k] then 
  (mapm print commands) 
#  (print (ls "/usr/bin"))
]
